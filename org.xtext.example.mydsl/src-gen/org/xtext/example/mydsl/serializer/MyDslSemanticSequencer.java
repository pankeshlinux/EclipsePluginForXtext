/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Action;
import org.xtext.example.mydsl.myDsl.ActionName;
import org.xtext.example.mydsl.myDsl.Actuator;
import org.xtext.example.mydsl.myDsl.ArchSpec;
import org.xtext.example.mydsl.myDsl.Command;
import org.xtext.example.mydsl.myDsl.CommandParameter;
import org.xtext.example.mydsl.myDsl.Consume;
import org.xtext.example.mydsl.myDsl.ConsumeForInBuilt;
import org.xtext.example.mydsl.myDsl.DataAccess;
import org.xtext.example.mydsl.myDsl.DatabaseName;
import org.xtext.example.mydsl.myDsl.DeploymentSpec;
import org.xtext.example.mydsl.myDsl.Device;
import org.xtext.example.mydsl.myDsl.DeviceAbilities;
import org.xtext.example.mydsl.myDsl.DeviceDescription;
import org.xtext.example.mydsl.myDsl.DeviceLocation;
import org.xtext.example.mydsl.myDsl.DeviceProtocol;
import org.xtext.example.mydsl.myDsl.EntityName;
import org.xtext.example.mydsl.myDsl.EventConditions;
import org.xtext.example.mydsl.myDsl.EventSensors;
import org.xtext.example.mydsl.myDsl.Field;
import org.xtext.example.mydsl.myDsl.Generate;
import org.xtext.example.mydsl.myDsl.InBuiltComputationalService;
import org.xtext.example.mydsl.myDsl.InBuiltComputationalServiceName;
import org.xtext.example.mydsl.myDsl.InteractionAction;
import org.xtext.example.mydsl.myDsl.InteractionSpec;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.OperationName;
import org.xtext.example.mydsl.myDsl.ParameterName;
import org.xtext.example.mydsl.myDsl.Parameters;
import org.xtext.example.mydsl.myDsl.PeriodicSensors;
import org.xtext.example.mydsl.myDsl.PlatformType;
import org.xtext.example.mydsl.myDsl.PrimitiveDataType;
import org.xtext.example.mydsl.myDsl.Region;
import org.xtext.example.mydsl.myDsl.RegionLabel;
import org.xtext.example.mydsl.myDsl.Request;
import org.xtext.example.mydsl.myDsl.SourceName;
import org.xtext.example.mydsl.myDsl.Spec;
import org.xtext.example.mydsl.myDsl.StorageService;
import org.xtext.example.mydsl.myDsl.Struct;
import org.xtext.example.mydsl.myDsl.Type;
import org.xtext.example.mydsl.myDsl.VocSpec;
import org.xtext.example.mydsl.myDsl.customComputationalService;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == MyDslPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ACTION:
				sequence_Action(context, (Action) semanticObject); 
				return; 
			case MyDslPackage.ACTION_NAME:
				sequence_ActionName(context, (ActionName) semanticObject); 
				return; 
			case MyDslPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case MyDslPackage.ARCH_SPEC:
				sequence_ArchSpec(context, (ArchSpec) semanticObject); 
				return; 
			case MyDslPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case MyDslPackage.COMMAND_PARAMETER:
				sequence_CommandParameter(context, (CommandParameter) semanticObject); 
				return; 
			case MyDslPackage.CONSUME:
				sequence_Consume(context, (Consume) semanticObject); 
				return; 
			case MyDslPackage.CONSUME_FOR_IN_BUILT:
				sequence_ConsumeForInBuilt(context, (ConsumeForInBuilt) semanticObject); 
				return; 
			case MyDslPackage.DATA_ACCESS:
				sequence_DataAccess(context, (DataAccess) semanticObject); 
				return; 
			case MyDslPackage.DATABASE_NAME:
				sequence_DatabaseName(context, (DatabaseName) semanticObject); 
				return; 
			case MyDslPackage.DEPLOYMENT_SPEC:
				sequence_DeploymentSpec(context, (DeploymentSpec) semanticObject); 
				return; 
			case MyDslPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case MyDslPackage.DEVICE_ABILITIES:
				sequence_DeviceAbilities(context, (DeviceAbilities) semanticObject); 
				return; 
			case MyDslPackage.DEVICE_DESCRIPTION:
				sequence_DeviceDescription(context, (DeviceDescription) semanticObject); 
				return; 
			case MyDslPackage.DEVICE_LOCATION:
				sequence_DeviceLocation(context, (DeviceLocation) semanticObject); 
				return; 
			case MyDslPackage.DEVICE_PROTOCOL:
				sequence_DeviceProtocol(context, (DeviceProtocol) semanticObject); 
				return; 
			case MyDslPackage.ENTITY_NAME:
				sequence_EntityName(context, (EntityName) semanticObject); 
				return; 
			case MyDslPackage.EVENT_CONDITIONS:
				sequence_EventConditions(context, (EventConditions) semanticObject); 
				return; 
			case MyDslPackage.EVENT_SENSORS:
				sequence_EventSensors(context, (EventSensors) semanticObject); 
				return; 
			case MyDslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MyDslPackage.GENERATE:
				sequence_Generate(context, (Generate) semanticObject); 
				return; 
			case MyDslPackage.IN_BUILT_COMPUTATIONAL_SERVICE:
				sequence_InBuiltComputationalService(context, (InBuiltComputationalService) semanticObject); 
				return; 
			case MyDslPackage.IN_BUILT_COMPUTATIONAL_SERVICE_NAME:
				sequence_InBuiltComputationalServiceName(context, (InBuiltComputationalServiceName) semanticObject); 
				return; 
			case MyDslPackage.INTERACTION_ACTION:
				sequence_InteractionAction(context, (InteractionAction) semanticObject); 
				return; 
			case MyDslPackage.INTERACTION_SPEC:
				sequence_InteractionSpec(context, (InteractionSpec) semanticObject); 
				return; 
			case MyDslPackage.OPERATION_NAME:
				sequence_OperationName(context, (OperationName) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_NAME:
				sequence_ParameterName(context, (ParameterName) semanticObject); 
				return; 
			case MyDslPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case MyDslPackage.PERIODIC_SENSORS:
				sequence_PeriodicSensors(context, (PeriodicSensors) semanticObject); 
				return; 
			case MyDslPackage.PLATFORM_TYPE:
				sequence_PlatformType(context, (PlatformType) semanticObject); 
				return; 
			case MyDslPackage.PRIMITIVE_DATA_TYPE:
				sequence_PrimitiveDataType(context, (PrimitiveDataType) semanticObject); 
				return; 
			case MyDslPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case MyDslPackage.REGION_LABEL:
				sequence_RegionLabel(context, (RegionLabel) semanticObject); 
				return; 
			case MyDslPackage.REQUEST:
				sequence_Request(context, (Request) semanticObject); 
				return; 
			case MyDslPackage.SOURCE_NAME:
				sequence_SourceName(context, (SourceName) semanticObject); 
				return; 
			case MyDslPackage.SPEC:
				sequence_Spec(context, (Spec) semanticObject); 
				return; 
			case MyDslPackage.STORAGE_SERVICE:
				sequence_StorageService(context, (StorageService) semanticObject); 
				return; 
			case MyDslPackage.STRUCT:
				sequence_Struct(context, (Struct) semanticObject); 
				return; 
			case MyDslPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MyDslPackage.VOC_SPEC:
				sequence_VocSpec(context, (VocSpec) semanticObject); 
				return; 
			case MyDslPackage.CUSTOM_COMPUTATIONAL_SERVICE:
				sequence_customComputationalService(context, (customComputationalService) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ActionName(EObject context, ActionName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACTION_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACTION_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getActionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (actionName=ActionName parameters+=Parameters*)
	 */
	protected void sequence_Action(EObject context, Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (actuatorName=EntityName actions+=Action*)
	 */
	protected void sequence_Actuator(EObject context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (structs+=Struct* inbuiltComputationalService+=InBuiltComputationalService* customComputationalService+=customComputationalService+)
	 */
	protected void sequence_ArchSpec(EObject context, ArchSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=[ParameterName|ID] parameter=CommandParameter?)
	 */
	protected void sequence_CommandParameter(EObject context, CommandParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (commandName=[ActionName|ID] commandparameter=CommandParameter? actuatorForCommand=[EntityName|ID])
	 */
	protected void sequence_Command(EObject context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=[SourceName|ID] SensorForConsume=[EntityName|ID])
	 */
	protected void sequence_ConsumeForInBuilt(EObject context, ConsumeForInBuilt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSUME_FOR_IN_BUILT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSUME_FOR_IN_BUILT__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSUME_FOR_IN_BUILT__SENSOR_FOR_CONSUME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSUME_FOR_IN_BUILT__SENSOR_FOR_CONSUME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConsumeForInBuiltAccess().getNameSourceNameIDTerminalRuleCall_1_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getConsumeForInBuiltAccess().getSensorForConsumeEntityNameIDTerminalRuleCall_3_0_1(), semanticObject.getSensorForConsume());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=[SourceName|ID] fromName=[EntityName|ID])
	 */
	protected void sequence_Consume(EObject context, Consume semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSUME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSUME__NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSUME__FROM_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSUME__FROM_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConsumeAccess().getNameSourceNameIDTerminalRuleCall_1_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getConsumeAccess().getFromNameEntityNameIDTerminalRuleCall_3_0_1(), semanticObject.getFromName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sourceName=SourceName dataAccessType=Type dataItem=ID type=Type actions+=Action*)
	 */
	protected void sequence_DataAccess(EObject context, DataAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (installedDatabase='MySQL' | installedDatabase='SQLAzure' | installedDatabase='MongoDB')
	 */
	protected void sequence_DatabaseName(EObject context, DatabaseName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     devices+=Device+
	 */
	protected void sequence_DeploymentSpec(EObject context, DeploymentSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (deviceEntityName=[EntityName|ID] name=DeviceAbilities?)
	 */
	protected void sequence_DeviceAbilities(EObject context, DeviceAbilities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     devicedescriptionText=STRING
	 */
	protected void sequence_DeviceDescription(EObject context, DeviceDescription semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEVICE_DESCRIPTION__DEVICEDESCRIPTION_TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEVICE_DESCRIPTION__DEVICEDESCRIPTION_TEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDeviceDescriptionAccess().getDevicedescriptionTextSTRINGTerminalRuleCall_0(), semanticObject.getDevicedescriptionText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (regionLabel=ID regionValue=INT)
	 */
	protected void sequence_DeviceLocation(EObject context, DeviceLocation semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEVICE_LOCATION__REGION_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEVICE_LOCATION__REGION_LABEL));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEVICE_LOCATION__REGION_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEVICE_LOCATION__REGION_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDeviceLocationAccess().getRegionLabelIDTerminalRuleCall_0_0(), semanticObject.getRegionLabel());
		feeder.accept(grammarAccess.getDeviceLocationAccess().getRegionValueINTTerminalRuleCall_2_0(), semanticObject.getRegionValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     protocolName='mqtt'
	 */
	protected void sequence_DeviceProtocol(EObject context, DeviceProtocol semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEVICE_PROTOCOL__PROTOCOL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEVICE_PROTOCOL__PROTOCOL_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDeviceProtocolAccess().getProtocolNameMqttKeyword_0_0(), semanticObject.getProtocolName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         deviceName=ID 
	 *         deviceLocation+=DeviceLocation 
	 *         platformType+=PlatformType 
	 *         deviceAbilities+=DeviceAbilities? 
	 *         deviceProtocol+=DeviceProtocol 
	 *         databaseName+=DatabaseName* 
	 *         deviceDescription+=DeviceDescription
	 *     )
	 */
	protected void sequence_Device(EObject context, Device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EntityName(EObject context, EntityName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENTITY_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENTITY_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEntityNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID eventConditions+=EventConditions?)
	 */
	protected void sequence_EventConditions(EObject context, EventConditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sensorName=EntityName generateInfo+=Generate+ eventConditions+=EventConditions)
	 */
	protected void sequence_EventSensors(EObject context, EventSensors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type+=Type)
	 */
	protected void sequence_Field(EObject context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sourceName=SourceName type=Type)
	 */
	protected void sequence_Generate(EObject context, Generate semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERATE__SOURCE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERATE__SOURCE_NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GENERATE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GENERATE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGenerateAccess().getSourceNameSourceNameParserRuleCall_1_0(), semanticObject.getSourceName());
		feeder.accept(grammarAccess.getGenerateAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InBuiltComputationalServiceName(EObject context, InBuiltComputationalServiceName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IN_BUILT_COMPUTATIONAL_SERVICE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IN_BUILT_COMPUTATIONAL_SERVICE_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInBuiltComputationalServiceNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         inBuiltComputationalServiceName=EntityName 
	 *         consumes+=ConsumeForInBuilt+ 
	 *         operationName=OperationName 
	 *         operationParameter=INT? 
	 *         generateInfo+=Generate+
	 *     )
	 */
	protected void sequence_InBuiltComputationalService(EObject context, InBuiltComputationalService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (actionName=ActionName parameters+=Parameters* interactionEntity=[EntityName|ID])
	 */
	protected void sequence_InteractionAction(EObject context, InteractionAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (interactionName=EntityName interactionCommand+=Command* interactionRequest+=Request* interactionNotify+=InteractionAction*)
	 */
	protected void sequence_InteractionSpec(EObject context, InteractionSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     OPERATION_NAME='AVG_BY_SAMPLE'
	 */
	protected void sequence_OperationName(EObject context, OperationName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OPERATION_NAME__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OPERATION_NAME__OPERATION_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOperationNameAccess().getOPERATION_NAMEAVG_BY_SAMPLEKeyword_0(), semanticObject.getOPERATION_NAME());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ParameterName(EObject context, ParameterName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETER_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETER_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (parameterName=ParameterName type=Type)
	 */
	protected void sequence_Parameters(EObject context, Parameters semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETERS__PARAMETER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETERS__PARAMETER_NAME));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PARAMETERS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PARAMETERS__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParametersAccess().getParameterNameParameterNameParserRuleCall_0_0(), semanticObject.getParameterName());
		feeder.accept(grammarAccess.getParametersAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sensorName=EntityName generateInfo+=Generate+)
	 */
	protected void sequence_PeriodicSensors(EObject context, PeriodicSensors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (deviceType='JavaSE' | deviceType='Android')
	 */
	protected void sequence_PlatformType(EObject context, PlatformType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         INTEGER='Integer' | 
	 *         BOOLEAN='boolean' | 
	 *         STRING='String' | 
	 *         LONG='long' | 
	 *         DOUBLE='double' | 
	 *         structDef=[Struct|ID]
	 *     )
	 */
	protected void sequence_PrimitiveDataType(EObject context, PrimitiveDataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_RegionLabel(EObject context, RegionLabel semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REGION_LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REGION_LABEL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRegionLabelAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (regionLabel=RegionLabel regionType=Type)
	 */
	protected void sequence_Region(EObject context, Region semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REGION__REGION_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REGION__REGION_LABEL));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REGION__REGION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REGION__REGION_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRegionAccess().getRegionLabelRegionLabelParserRuleCall_0_0(), semanticObject.getRegionLabel());
		feeder.accept(grammarAccess.getRegionAccess().getRegionTypeTypeParserRuleCall_2_0(), semanticObject.getRegionType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (requestname=[SourceName|ID] storageForRequest=[EntityName|ID])
	 */
	protected void sequence_Request(EObject context, Request semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REQUEST__REQUESTNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REQUEST__REQUESTNAME));
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REQUEST__STORAGE_FOR_REQUEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REQUEST__STORAGE_FOR_REQUEST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRequestAccess().getRequestnameSourceNameIDTerminalRuleCall_1_0_1(), semanticObject.getRequestname());
		feeder.accept(grammarAccess.getRequestAccess().getStorageForRequestEntityNameIDTerminalRuleCall_3_0_1(), semanticObject.getStorageForRequest());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SourceName(EObject context, SourceName semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SOURCE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SOURCE_NAME__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSourceNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (vocSpec=VocSpec | interactionSpec=InteractionSpec | archSpec=ArchSpec | networkSpec=DeploymentSpec)
	 */
	protected void sequence_Spec(EObject context, Spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (storageServiceName=EntityName dataAccesses+=DataAccess*)
	 */
	protected void sequence_StorageService(EObject context, StorageService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID fields+=Field+)
	 */
	protected void sequence_Struct(EObject context, Struct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     primitiveDataType=PrimitiveDataType
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TYPE__PRIMITIVE_DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TYPE__PRIMITIVE_DATA_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeAccess().getPrimitiveDataTypePrimitiveDataTypeParserRuleCall_0(), semanticObject.getPrimitiveDataType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (structs+=Struct+ periodicSensors+=PeriodicSensors* eventSensors+=EventSensors* actuators+=Actuator* storageService+=StorageService*)
	 */
	protected void sequence_VocSpec(EObject context, VocSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (customComputationalServiceName=EntityName consumes+=Consume+ requests+=Request* generateInfo+=Generate* commands+=Command*)
	 */
	protected void sequence_customComputationalService(EObject context, customComputationalService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
